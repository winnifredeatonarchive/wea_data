<?xml version="1.0" encoding="UTF-8"?>
<!--Processing instructions for the TEI ODDs rng-->
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns:xi="http://www.w3.org/2001/XInclude"
     xmlns:svg="http://www.w3.org/2000/svg"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
     xmlns:math="http://www.w3.org/1998/Math/MathML"
     xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
     xmlns="http://www.tei-c.org/ns/1.0"
     xmlns:sch="http://purl.oclc.org/dsdl/schematron">
  <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>ODD Customization for the Winniferd Eaton Archive Project</title>
            <respStmt>
               <resp>Author</resp>
               <name>Joey Takeda</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <p>Open access?</p>
         </publicationStmt>
         <sourceDesc>
            <p>Born digital.</p>
         </sourceDesc>
      </fileDesc>
  </teiHeader>
  <text>
      <body>

         <div>
            <head>Introduction</head>
            <p>The following are the Guidelines and schema specification for the Winnifred Eaton Archive project (WEA). The project
        uses a highly constrained version of the TEI Guidelines; the texts are lightly encoded with very little linked data. Primarily,
        the texts are meant to be easily ported into an existing Omeka framework; the details of this framework are still in development.</p>
         </div>
         <div>
            <head>Requirements</head>
            <p>To edit material for the site, you will need to use a computer with the following software:
        <list>
                  <item>Git (to get data from and commit data to  the repository). Most computers come with git automatically installed. To check this, open the Command Line (Windows) / Terminal (Mac/Linux) and type in <code rend="block">git --version</code>. If you get something like this in response: <code rend="block">git version 2.17.2 (Apple Git-113)</code>, then you have Git installed. Otherwise, follow the instructions <ref target="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">here</ref>.</item>
                  <item>oXygen XML Editor. (For current RAs, talk to Mary Chapman about licensing.)</item>
                  <item>You must also set up a free Github account <ref target="https://github.com/">here</ref>. It will be connected to your email address; once the Github account is set up, let the repository owner (currently Joey Takeda) know the email address used so that they can grant you write access to the repository.</item>
               </list>
            </p>
         </div>
         

         <div xml:id="github">
            <head>Using Github</head>
            <p>All of the data for the project is kept in a Git repository that is hosted through Github. Git is a version control system, which means that one could "roll back" the site to any particular version, and retrieve any file at any state of editing. Note that Github is a public repository, so all of the data and commit messages you make are visible to anyone. Our Github repository URL is <ref target="https://github.com/winnifredeatonarchive/wea_data">https://github.com/winnifredeatonarchive/wea_data</ref>.</p>
            <p/>
            <div xml:id="github_get">
               <head>Setting up the repository</head>
               <p>To get the data, you must first checkout a copy of the repository as follows:</p>
               <list>
                  <item>Open the terminal</item>
                  <item>Create a directory for working in: <code rend="block">mkdir wea</code>

                  </item>
                  <item>Go into the directory: <code rend="block">cd wea</code>
                  </item>
                  <item>Initialize the repository: <code rend="block">git init .</code>
                  </item>
                  <figure>
                     <graphic url="../graphics/git_checkout_1.gif"/>
                  </figure>
                  <item>Pull the repository: <code rend="block">git pull https://github.com/winnifredeatonarchive/wea_data</code>
                  </item>
                  <figure>
                     <graphic url="../graphics/git_checkout_2.gif"/>
                  </figure>
               </list>
               <p>Note that you only need to do this the first time you start working in the Github repository.</p>
            </div>
        
            <div>
               <head>The Github Workflow</head>
               <p>The normal workflow for working in Github (and any version software) is as follows:
          <list>
                     <item>Update your repository so that any changes made by others are pushed into your local system</item>
                     <item>Commit the items to the repository</item>
                     <item>Push those items to the Github interface</item>
                  </list>
               </p>
               <div>
                  <head>Updating</head>
                  <p>Make sure to update as often as possible; always update at the beginning of your working session. </p>
                  <list>
                     <item>Go into your working folder: 
                        <code rend="block">cd wea</code>
                     </item>
                     <item>Pull the repository:
                        <code rend="block">git pull</code>
                     </item>
                     <figure>
                        <graphic url="../graphics/git_pull_1.gif"/>
                     </figure>
                  </list>
               </div>
               <div>
                  <head>Committing</head>
                  <p>Unlike some versioning systems, Github requires three steps for committing/saving your work to the repository.
            <list>
                        <item>First, check the status of your files to see what you have changed since your last commit:
              <code rend="block">git status</code>
              If there are no changes to the repository, then you'll like see something like this:
              <code rend="block">
                On branch master
                nothing to commit, working tree clean
              </code>
              If there are changes, you should see something like this:
              
              <code rend="block">
                On branch master
                Changes not staged for commit:
                (use "git add &lt;file&gt;..." to update what will be committed)
                (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
                
                modified:   README.md
                
                no changes added to commit (use "git add" and/or "git commit -a")
              </code>
                        </item>
                        <figure>
                           <graphic url="../graphics/git_status_1.gif"/>
                        </figure>
                        <item>If there are changes, then add the files/folders that you want to commit to the repository.
              <code rend="block">git add data/texts/My_Title.xml</code>
                        </item>
                        <figure>
                           <graphic url="../graphics/git_add_1.gif"/>
                        </figure>
                        <item>Third, commit the files to the repository, including a commit message that explains what you did:
              <code rend="block">git commit -m "Adding new file."</code>
                        </item>
                        <figure>
                           <graphic url="../graphics/git_commit_1.gif"/>
                        </figure>
                        <item>Fourth, push the files to the repository:
              <code rend="block">git push</code>
                           <figure>
                              <graphic url="../graphics/git_push_first_1.gif"/>
                           </figure>
              Note that, if you are committing for the first time, you'll like see something like this:
              <code rend="block">
                Either specify the URL from the command-line or configure a remote repository using
                
                git remote add &lt;name&gt; &lt;url&gt;
                
                and then push using the remote name
                
                git push &lt;name&gt;
              </code>

              This means that you must set up your local copy to track the changes in the global repository. To do that, simply follow the above instructions like so:
                <code rend="block">git remote add wea https://github.com/winnifredeatonarchive/wea_data</code>
                           <code rend="block">git push wea</code>
                           <figure>
                              <graphic url="../graphics/git_remote_add_1.gif"/>
                           </figure>
                You'll then like get another message, saying something like:
                <code rend="block">fatal: The current branch master has no upstream branch.
                  To push the current branch and set the remote as upstream, use
                  
                  git push --set-upstream wea master
                  
                </code>
                To resolve that, simply:
                <code rend="block">
                  git push --set-upstream wea master
                </code>
                           <figure>
                              <graphic url="../graphics/git_push_2.gif"/>
                           </figure>
                You may then be prompted for your username and password; if this is your first commit, then it might give your instructions on how to store those credentials in your local git system so that you do not need to add your username and password every time you commit.
              </item>
                     </list>
                  </p>
               </div>
            </div>
            <div xml:id="github_summary">
               <head>Github Summary</head>
               <p>The basic steps for working with Github are:
                  
                  <list>
                     <item>Open a the Terminal or Command Line (on Mac, use the ⌘ + spacebar and type "Terminal" to find it)</item>
                     <item>Go into your working directory (likely called "wea"):
                        <code rend="block">cd wea</code>
                     </item>
                  </list>
                  Before you start working:
                  <list>
                     <item>Pull the changes from the repository so that your repository is up-to-date:
                        <code rend="block">git pull</code>
                     </item>
                  </list>
                  While you're working:
                  <list>
                     <item>Save your file (using command/ctrl + S like in MS Word)</item>
                     <item>Validate by pressing the red checkmark button in the toolbar in oXygen</item>
                  </list>
                  Once your file is valid and you want to save the file to the repository:
                  <list>
                     <item>Stage your file to be committed:
                        <code rend="block">git add .</code>
                     </item>
                     <item>Commit your changes:
                        <code rend="block">git commit -m</code>
                     </item>
                     <item>Push your changes to the repository:
                        <code rend="block">git push</code>
                     </item>
                  </list>
               </p>
            </div>
         </div>
      
         <div>
            <head>Creating a New Text in oXygen</head>
            <p>To create a new text file, use the built in text template</p>
            <list>
               <item>First, in the project view in oXygen, right click the data/texts folder and click "Add new file"</item>
               <figure>
                  <graphic url="../graphics/create_new_file_1.gif"/>
               </figure>
               <item>Select "wea_template.xml" and give your file a name. The name should be two or three words, separated with underscores.</item>
               <figure>
                  <graphic url="../graphics/create_new_file_2.gif"/>
               </figure>
               <item>Input the (modernized) title of the document</item>
               <figure>
                  <graphic url="../graphics/create_new_file_3.gif"/>
               </figure>
               <item>Select the transciber</item>
               <figure>
                  <graphic url="../graphics/create_new_file_4.gif"/>
               </figure>
               <item>Select the copy editor</item>
               <figure>
                  <graphic url="../graphics/create_new_file_5.gif"/>
               </figure>
               <item>Select the encoder (who is usually you)</item>
               <figure>
                  <graphic url="../graphics/create_new_file_6.gif"/>
               </figure>
               <item>Select the genre</item>
               <figure>
                  <graphic url="../graphics/create_new_file_7.gif"/>
               </figure>
               <item>Select the location (usually derived from the Google Drive folder structure)</item>
               <figure>
                  <graphic url="../graphics/create_new_file_8.gif"/>
               </figure>
               <item>Your new document should be created!</item>
               <figure>
                  <graphic url="../graphics/create_new_file_9.gif"/>
               </figure>
               <item>Remember to commit the changes to the repository using the above instructions.</item>
            </list>
        
         </div>
         
         <div>
            <head>Encoding a Primary Source Document</head>
            <p>Below are abbreviated discussions on how to encode various features of a text</p>
            <div>
               <head>Structure</head>
               <p>All content of the texts goes into the <gi>body</gi> element. Surround all content with a <gi>div</gi> element like so:
               
                  <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <body>
                        <div>
                           <!--Content goes here-->
                        </div>
                     </body>
                  </egXML>
               </p>
               <p>Individual sections can be encoded using nested <gi>div</gi> tags, if desired:
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <body>
                        <div>
                           <head>A Poor Devil</head>
                           <opener>
                              <opener>
                                 <byline>By <name ref="pers:WE">Winnie Eaton</name>, Montreal.</byline>
                                 <note>[Written for the Metropolitan.]</note>
                              </opener>
                           </opener>
                           <div>
                           <!--Section 1-->
                              <div>
                              <!--Section 1.1-->
                           </div>
                              <div>
                              <!--Section 1.2-->
                           </div>
                           </div>
                           <div>
                           <!--Section 2-->
                        </div>
                        </div>
                     </body>
                  </egXML>
               </p>
            </div>
            <div>
               <head>Openers and Closers</head>
               <p>Most of the texts have some sort of header or closer with the author's name, date of publication, et cetera. Use the <gi>opener</gi> element if this occurs at the beginning of the text and the <gi>closer</gi> element if it is at the bottom.</p>
            </div>
            <div>
               <head>Bylines</head>
               <p>If there is an authorial statement of responsibility of some sort, enclose this in a <gi>byline</gi> element. Tag Winnifred Eaton's name (in whatever psuedonymic form it appears) with the <gi>name</gi> tag
               with an <att>ref</att> value of <val>pers:WE</val>.</p>
            </div>
            <div>
               <head>Gaps and omissions</head>
               <p>If the text cannot be transcribed for some reason (damage, etc), then use the <gi>gap</gi> element to signify that there is a gap in transcription:
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <gap reason="damaged"/>
                  </egXML>
               </p>
               <p>If you can supply the damaged text, use the <gi>supplied</gi> element instead with an <att>resp</att> value pointing to your <att>xml:id</att> (which is usually your initials):
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <supplied resp="pers:JT">ed</supplied>
                  </egXML>
               </p>
               <p>You can encode how certain you are of your editorial addition by using the <att>cert</att> attribute on supplied with a value of "low" "medium" or "high". If no <att>cert</att> is supplied, it is assumed
               that it has a high value of certainty:
               <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <supplied resp="pers:JT" cert="low">ed</supplied>
                  </egXML>
               </p>
            </div>
            <div xml:id="codeTemplates">
               <head>Code Templates (Shortcuts)</head>
               <p>The table below lists keyboard shortcuts for inserting common encoding features in a text. In most cases, the code template simply requires selecting (i.e. highlighting) the bit of text you want to encode and then typing in the keystroke; the exception currently is the gap element shortcut, which is simply inserted where your cursor is in the document.</p>
               
               <table>
                  <row>
                     <cell>M1</cell>
                     <cell>Command key on MacOS X, Ctrl on other platforms.</cell>
                  </row>
                  <row>
                     <cell>M2</cell>
                     <cell>Shift</cell>
                  </row>
                  <row>
                     <cell>M3</cell>
                     <cell>Option on Mac OS X, Alt on other platforms</cell>
                  </row>
               </table>
               <table xml:id="codeTemplates_table">
                  <row role="label">
                     <cell>Name</cell>
                     <cell>Description</cell>
                     <cell>Result</cell>
                     <cell>Keystroke</cell>
                  </row>
                  <row>
                     <cell>Insert left quotation mark</cell>
                     <cell>Insert the the opening curly quotation mark</cell>
                     <cell>
                        <code>“</code>
                     </cell>
                     <cell>M1 M2 L</cell>
                  </row>
                  <row>
                     <cell>Insert left single quote</cell>
                     <cell>Inserts the opening single curly apostrophe</cell>
                     <cell>
                        <code>‘</code>
                     </cell>
                     <cell>M1 M2 A</cell>
                  </row>
                  <row>
                     <cell>Insert right curly quote</cell>
                     <cell>Inserts the closing curly quotation mark</cell>
                     <cell>
                        <code>”</code>
                     </cell>
                     <cell>M1 M2 R</cell>
                  </row>
                  <row>
                     <cell>Tag foreign</cell>
                     <cell>Tag a foreign selection</cell>
                     <cell>
                        <code>&lt;foreign&gt;${selection}&lt;/foreign&gt;</code>
                     </cell>
                     <cell>M1 M2 F</cell>
                  </row>
                  <row>
                     <cell>Tag gap</cell>
                     <cell>Insert a gap element</cell>
                     <cell>
                        <code>&lt;gap reason="${caret}"/&gt;</code>
                     </cell>
                     <cell>M1 M2 G</cell>
                  </row>
                  <row>
                     <cell>Tag paragraph</cell>
                     <cell>Tag a paragraph</cell>
                     <cell>
                        <code>&lt;p&gt;${selection}&lt;/p&gt;</code>
                     </cell>
                     <cell>M1 M2 P</cell>
                  </row>
                  <row>
                     <cell>Tag Winnifred Eaton's name</cell>
                     <cell>Tag a reference to Winnifred Eaton</cell>
                     <cell>
                        <code>&lt;name ref="pers:WE1"&gt;${selection}&lt;/name&gt;</code>
                     </cell>
                     <cell>M1 M2 W</cell>
                  </row>
               </table>
               
            </div>
         </div>
         <div>
            <head>Building the Schema</head>
            <p>All constraints and documentation are contained within the ODD file, including the RelaxNG schema, the schematron file, and the compiled schematron XSLT.</p>
            <p>To regenerate the schema and the documentation follow these directions</p>
            <p>
               <emph>In oXygen</emph>: Simply open the ODD file in the oXygen project file and press the red "play" button.</p>
            <p>
               <emph>Command line</emph>: in the root project directory (<code>wea_data</code>), run:
               <code rend="block">ant -lib lib -f code/buildSchemas.xml</code>
               Note that you must have ant installed.
            </p>
         </div>

      </body>
      <back>
         <div>
            <schemaSpec ident="wea" start="TEI">
               <moduleRef key="analysis" include="pc"/>
          
               <moduleRef key="core"
                          include="author bibl choice corr date divGen editor emph foreign gap head hi item l lg list listBibl milestone name note num orig p pb pubPlace publisher q quote ref reg relatedItem resp respStmt sic term title unclear"/>
               <moduleRef key="header"
                          include="abstract authority availability biblFull catRef catDesc category change classDecl creation distributor edition editorialDecl encodingDesc fileDesc hyphenation idno langUsage language licence listChange listPrefixDef prefixDef profileDesc projectDesc publicationStmt rendition revisionDesc sourceDesc taxonomy teiHeader textClass titleStmt"/>
               
               <moduleRef key="namesdates"
                          include="birth death event forename listEvent listOrg listPerson listPlace listRelation location nationality occupation orgName persName person place placeName surname"/>
               <moduleRef key="tagdocs" include="att code gi val"/>
               <!--Include all TEI modules-->
               <moduleRef key="tei"/>
          
               <moduleRef key="textstructure"
                          include="TEI back body byline closer dateline div docAuthor docDate docTitle epigraph front opener text titlePage titlePart trailer"/>
          
               <moduleRef key="transcr" include="supplied"/>
          
               <!--MODULE: HEADER-->
          
               <elementSpec ident="teiHeader" module="header" mode="change">
            <!--Make all the bits we want of the teiHeader mandatory-->
                  <content>
                     <elementRef key="fileDesc"/>
                     <elementRef key="profileDesc"/>
                     <!--Make encodingDesc optional-->
                     <elementRef key="encodingDesc" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="revisionDesc"/>
                  </content>
               </elementSpec>
          
               <!--Make profileDesc/textClass mandatory-->
               <elementSpec ident="profileDesc" module="header" mode="change">
                  <content>
                     <elementRef key="textClass"/>
                  </content>
               </elementSpec>
          
               <!--And make at least one catRef mandatory-->
               <elementSpec ident="textClass" module="header" mode="change">
                  <content>
                     <elementRef key="catRef" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
                  <constraintSpec scheme="schematron" ident="textClass.oneofEach">
                     <desc>An XSLT restraint for one of each catRef</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:textClass">
                              <sch:assert test="tei:catRef[@scheme='wdt:docType']">
                            ERROR: Missing category reference docType.
                        </sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:textClass">
                              <sch:assert test="tei:catRef[@scheme='wdt:genre']">
                            ERROR: Missing category reference genre.
                        </sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:textClass">
                              <sch:assert test="tei:catRef[@scheme='wdt:category']">
                            ERROR: Missing category reference category.
                        </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
    
               </elementSpec>
          
               <elementSpec ident="catRef" module="header" mode="change">

                  <constraintSpec scheme="schematron" ident="catRef.occurence">
                     <desc>An XsLT generated co-occurence constraint</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:catRef[@scheme='wdt:docType']">
                              <sch:assert test="matches(@target,'^((wdt:docPrimarySource)|(wdt:docPrimarySourceMS)|(wdt:docPrimarySourcePublished)|(wdt:docBornDigital))$')">
                            ERROR: Value <sch:value-of select="@target"/> not allowed for category reference <sch:value-of select="@scheme"/>
                              </sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:catRef[@scheme='wdt:genre']">
                              <sch:assert test="matches(@target,'^((wdt:genreShortStory)|(wdt:genreNF)|(wdt:genreNFAuto)|(wdt:genreNFDedication)|(wdt:genreNFInterview)|(wdt:genreNFIntroduction)|(wdt:genreNFEthnography)|(wdt:genreFilm)|(wdt:genreFilmScenario)|(wdt:genreFilmTreatment)|(wdt:genrePoem)|(wdt:genreNovel)|(wdt:genreNovelSerial))$')">
                            ERROR: Value <sch:value-of select="@target"/> not allowed for category reference <sch:value-of select="@scheme"/>
                              </sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:catRef[@scheme='wdt:category']">
                              <sch:assert test="matches(@target,'^((wdt:catJapan)|(wdt:catAlberta)|(wdt:catHollywood)|(wdt:catEarlyExperiment)|(wdt:catNewYork))$')">
                            ERROR: Value <sch:value-of select="@target"/> not allowed for category reference <sch:value-of select="@scheme"/>
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                     
                  </constraintSpec>
                  <attList>
                     <attDef ident="cert" mode="delete"/>
                     <attDef ident="change" mode="delete"/>
                     <attDef ident="facs" mode="delete"/>
                     <attDef ident="rend" mode="delete"/>
                     <attDef ident="source" mode="delete"/>
                     <attDef ident="xml:id" mode="delete"/>
                     <attDef ident="xml:lang" mode="delete"/>
                     <attDef ident="corresp" mode="delete"/>
                     <attDef ident="n" mode="delete"/>
                     <attDef ident="next" mode="delete"/>
                     <attDef ident="prev" mode="delete"/>
                     <attDef ident="rendition" mode="delete"/>
                     <attDef ident="resp" mode="delete"/>
                     <attDef ident="style" mode="delete"/>
                     <!--Auto generated values-->
                     <attDef ident="scheme" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="wdt:docType">
                              <desc>Document Type</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genre">
                              <desc>Genre</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:category">
                              <desc>Locations</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="target" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="wdt:docPrimarySource">
                              <desc>Primary Source</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docPrimarySourceMS">
                              <desc>Primary Source in Manuscript</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docPrimarySourcePublished">
                              <desc>Published Primary Source</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docBornDigital">
                              <desc>Born Digital document</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreShortStory">
                              <desc>Short Story</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNF">
                              <desc>Non-fiction</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFAuto">
                              <desc>Non-fiction: Autobiography</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFDedication">
                              <desc>Non-fiction: Dedication</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFInterview">
                              <desc>Non-Fiction: Interview</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFIntroduction">
                              <desc>Non-fiction: Introduction</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFEthnography">
                              <desc>Non-fiction: Ethnography</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilm">
                              <desc>Film</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilmScenario">
                              <desc>Film: Scenario</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilmTreatment">
                              <desc>Film: Treatment</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genrePoem">
                              <desc>Poem</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNovel">
                              <desc>Novel</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNovelSerial">
                              <desc>Novel: Serial</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:catJapan">
                              <desc>Japan</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:catAlberta">
                              <desc>Alberta</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:catHollywood">
                              <desc>Hollywood</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:catEarlyExperiment">
                              <desc>Early Experiments</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:catNewYork">
                              <desc>New York</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     
                  </attList>
                  
               </elementSpec>
         
          
               <elementSpec mode="change" module="header" ident="sourceDesc">
                  <content>
                     <alternate>
                        <elementRef key="p"/>
                        <elementRef key="bibl"/>
                     </alternate>
                  </content>
                  <constraintSpec ident="useBiblInPS" scheme="schematron">
                     <desc>All primary sources must use a <gi>bibl</gi> element in the <gi>sourceDesc</gi>
                     </desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:sourceDesc[not(tei:bibl)]">
                              <sch:assert test="some $d in $docTypes satisfies matches($d, 'BornDigital')">
                      ERROR: All not born digital documents must use a &lt;bibl&gt; element in their
                      source descriptions.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               
               <elementSpec ident="name" module="core" mode="change">
                  <attList>
                     <attDef ident="ref" mode="add">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="pers:WE1">
                              <desc>WE1</desc>
                              <gloss>Winnifred Eaton</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:SE1">
                              <desc>SE1</desc>
                              <gloss/>
                           </valItem>
                           <valItem mode="add" ident="pers:AB1">
                              <desc>AB1</desc>
                              <gloss/>
                           </valItem>
                           <valItem mode="add" ident="pers:MC1">
                              <desc>MC1</desc>
                              <gloss>Mary Chapman</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:JLC1">
                              <desc>JLC1</desc>
                              <gloss>Jean Lee Cole</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:SL1">
                              <desc>SL1</desc>
                              <gloss>Sydney Lines</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:KI1">
                              <desc>KI1</desc>
                              <gloss>Ken Ip</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:JT1">
                              <desc>JT1</desc>
                              <gloss>Joey Takeda</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:HB1">
                              <desc>HB1</desc>
                              <gloss>Hilary Ball</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:XY1">
                              <desc>XY1</desc>
                              <gloss>Xine Yao</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:PP1">
                              <desc>PP1</desc>
                              <gloss>Pavlina Pajot</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:LM1">
                              <desc>LM1</desc>
                              <gloss>Lucia Maggio</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               
               <!--Modify persName so that we need at least one of reg, forename, and surname-->
               <elementSpec ident="persName" module="namesdates" mode="change">
                  <content>
                     <elementRef key="reg" minOccurs="1" maxOccurs="1"/>
                     <elementRef key="forename" minOccurs="1" maxOccurs="unbounded"/>
                     <elementRef key="surname" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
               </elementSpec>
               
               
               <!--CLASS SPECS-->
               <!--
               <classSpec type="atts" module="tei" ident="att.canonical" mode="change">
                  <attList>
                     <attDef ident="key" mode="delete"/>
                  </attList>
               </classSpec>-->
               <classSpec ident="att.ranging" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.written" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.cReferencing" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.datable" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="period" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.datcat" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.declarable" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.declaring" module="tei" type="atts" mode="delete"/>
               <!--WE need this for rhyme-->
               <classSpec ident="att.divLike" module="tei" type="atts" mode="delete"/>               
               <classSpec ident="att.docStatus" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="status" mode="change">
                        <valList mode="add" type="open">
                           <valItem ident="draft" mode="add">
                              <gloss>This document is currently being edited. It is not ready for
                                 publication or peer-review.</gloss>
                           </valItem>
                           <valItem ident="published" mode="add">
                              <gloss>This document is ready to be published.</gloss>
                           </valItem>
                           <valItem ident="deprecated" mode="add">
                              <gloss>This document is no longer relevant, but is being preserved for
                                 archival purposes.</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec>
               <classSpec ident="att.global.responsibility"
                          module="tei"
                          type="atts"
                          mode="change">
                  <attList>
                     <attDef ident="resp" mode="change">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="pers:WE1">
                              <desc>WE1</desc>
                              <gloss>Winnifred Eaton</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:SE1">
                              <desc>SE1</desc>
                              <gloss/>
                           </valItem>
                           <valItem mode="add" ident="pers:AB1">
                              <desc>AB1</desc>
                              <gloss/>
                           </valItem>
                           <valItem mode="add" ident="pers:MC1">
                              <desc>MC1</desc>
                              <gloss>Mary Chapman</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:JLC1">
                              <desc>JLC1</desc>
                              <gloss>Jean Lee Cole</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:SL1">
                              <desc>SL1</desc>
                              <gloss>Sydney Lines</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:KI1">
                              <desc>KI1</desc>
                              <gloss>Ken Ip</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:JT1">
                              <desc>JT1</desc>
                              <gloss>Joey Takeda</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:HB1">
                              <desc>HB1</desc>
                              <gloss>Hilary Ball</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:XY1">
                              <desc>XY1</desc>
                              <gloss>Xine Yao</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:PP1">
                              <desc>PP1</desc>
                              <gloss>Pavlina Pajot</gloss>
                           </valItem>
                           <valItem mode="add" ident="pers:LM1">
                              <desc>LM1</desc>
                              <gloss>Lucia Maggio</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec>
               <classSpec ident="att.duration.w3c" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.duration.iso" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.editLike" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.global" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="xml:base" mode="delete"/>
                     <attDef ident="xml:space" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.global.rendition"
                          module="tei"
                          type="atts"
                          mode="change">
                  <attList>
                     <attDef ident="rend" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.handFeatures" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.interpLike" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.measurement" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.naming" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.notation" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.pointing" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="targetLang" mode="delete"/>
                     <attDef ident="evaluate" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.pointingGroup"
                          module="tei"
                          type="atts"
                          mode="delete"/>
               <classSpec ident="att.scoping" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.segLike" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.sortable" module="tei" type="atts" mode="delete"/>
                <classSpec ident="att.edition" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.readFrom" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.spanning" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.repeatable" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.timed" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.transcriptional"
                          type="atts"
                          module="tei"
                          mode="delete"/>
               <classSpec ident="att.translatable" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.citing" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.partials" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.personal" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="full" mode="delete"/>
                     <attDef ident="sort" mode="delete"/>
                  </attList>
               </classSpec>
               
               
               <classSpec ident="att.global.analytic"
                          type="atts"
                          module="tei"
                          mode="delete"/>
               <classSpec ident="att.pointing.group"
                          type="atts"
                          module="tei"
                          mode="delete"/>
               
               <!--CONSTRAINTS-->
          
               <constraintSpec ident="global" scheme="schematron">
                  <constraint>
              
                     <sch:pattern>
                        <sch:let name="spaceRegex" value="'(^\s)|(\s$)'"/>
                        <sch:let name="docId" value="root(/)/tei:*/@xml:id"/>
                        <sch:let name="docUri" value="document-uri(/)"/>
                        <sch:let name="docIds" value="//tei:*[@xml:id]/@xml:id"/>
                        <sch:let name="docTypes" value="//tei:catRef/@target"/>
                        <sch:let name="docStatus" value="//tei:revisionDesc/@status"/>
                        
                        <sqf:fix id="globals">
                           <sqf:description>
                              <sqf:title>Global Templates</sqf:title>
                           </sqf:description>
                           
                           <!--GLOBAL XSL VARIABLES-->
                           <xsl:variable name="apos">'</xsl:variable>
                           <xsl:variable name="dq">"</xsl:variable>
                              <!--TAG BLOCKS TEMPLATE-->
                              <xsl:template name="tagBlocks">
                                 <xsl:param name="verse" select="false()"/>
                                 <xsl:variable name="ancestors" select="count(ancestor::tei:*)"/>
                                 <xsl:variable name="tabCount" select="$ancestors"/>
                                 <xsl:variable name="newLine">
                                    <xsl:text>
</xsl:text>
                                 </xsl:variable>
                                 <xsl:variable name="tab"
                                            select="string-join(for $n in (2 to $tabCount) return '&#x9;','')"/>
                                 <xsl:variable name="paras"
                                            select="for $t in tokenize(.,'\n+') return normalize-space($t)"/>
                                 <xsl:for-each select="$paras[not(.='')]">
                                    <xsl:value-of select="$newLine"/>
                                    <xsl:value-of select="$tab"/>
                                    <xsl:element name="{if ($verse) then 'l' else 'p'}">
                                       <xsl:value-of select="."/>
                                    </xsl:element>
                                 </xsl:for-each>
                              </xsl:template>
                           
                           <xsl:template name="replaceApos">
                              <xsl:param name="useDq" select="false()"/>
                              <xsl:variable name="thisApos" select="if ($useDq) then $dq else $apos"/>
                              <xsl:variable name="left" select="if ($useDq) then '“' else '‘'"/>
                              <xsl:variable name="right" select="if ($useDq) then '”' else '’'"/>
                              <xsl:analyze-string select="." regex="{concat('(^|\s+)',$thisApos)}">
                                 <xsl:matching-substring>
                                    <xsl:value-of select="regex-group(1)"/>
                                    <xsl:value-of select="$left"/>
                                 </xsl:matching-substring>
                                 <xsl:non-matching-substring>
                                    <xsl:analyze-string select="." regex="{concat('([a-zA-Z])',$thisApos)}">
                                       <xsl:matching-substring>
                                          <xsl:value-of select="regex-group(1)"/>
                                          <xsl:value-of select="$right"/>
                                       </xsl:matching-substring>
                                       <xsl:non-matching-substring>
                                          <xsl:analyze-string select="." regex="{concat($thisApos,'(\s+|$)')}">
                                             <xsl:matching-substring>
                                                <xsl:value-of select="$right"/>
                                                <xsl:value-of select="regex-group(1)"/>
                                             </xsl:matching-substring>
                                             <xsl:non-matching-substring>
                                                <xsl:value-of select="."/>
                                             </xsl:non-matching-substring>
                                          </xsl:analyze-string>
                                       </xsl:non-matching-substring>
                                    </xsl:analyze-string>
                                 </xsl:non-matching-substring>
                              </xsl:analyze-string>
                           </xsl:template>
                           
                           
                           <xsl:template name="tagQuote">
                              <xsl:param name="left"/>
                              <xsl:param name="right"/>
                              <xsl:variable name="rex1" select="concat($left,'([^',$right,']+)([\.,])',$right)"/>
                              <xsl:variable name="rex2" select="concat($left,'([^',$right,']+)',$right)"/>
                              <xsl:analyze-string select="." regex="{$rex1}">
                                 <xsl:matching-substring>
                                    <xsl:element name="q">
                                       <xsl:value-of select="regex-group(1)"/>
                                    </xsl:element>
                                    <xsl:value-of select="regex-group(2)"/>
                                 </xsl:matching-substring>
                                 <xsl:non-matching-substring>
                                    <xsl:analyze-string select="." regex="{$rex2}">
                                       <xsl:matching-substring>
                                          <xsl:element name="q">
                                             <xsl:value-of select="regex-group(1)"/>
                                          </xsl:element>
                                       </xsl:matching-substring>
                                       <xsl:non-matching-substring>
                                          <xsl:value-of select="."/>
                                       </xsl:non-matching-substring>
                                    </xsl:analyze-string>
                                 </xsl:non-matching-substring>
                              </xsl:analyze-string>
                           </xsl:template>
                        </sqf:fix>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
          
               <!--Basic constraints-->
               <constraintSpec scheme="schematron" ident="TEI.docNameSameAsId">
                  <desc>All root elements must have an <att>xml:id</att> that matches the document filename.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="/tei:TEI[not(ancestor::tei:teiCorpus)] | /tei:teiCorpus">
                           <sch:assert test="@xml:id and matches($docUri,concat('[/\\]',$docId,'.xm[l_]$'))"> ERROR: Document
                    xml:id (<sch:value-of select="$docId"/>) does not match the document file
                    name (<sch:value-of select="$docUri"/>). </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               
               

               <constraintSpec scheme="schematron" ident="misMatchedQuote">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:*[not(ancestor-or-self::tei:code)][text()]">
                           <sch:let name="onlyOneQuote"
                                    value="some $t in text() satisfies (not(count(tokenize($t,'”')) = count(tokenize($t,'“'))))"/>
                           <sch:assert test="not($onlyOneQuote)">
                              ERROR: Curly quotes that cannot be QuickFixed. Either add the curly quotation mark or change to the q element.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               
             
               <constraintSpec scheme="schematron" ident="noSpaceInRefs">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:name | tei:ref | tei:title | tei:l">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'^\s+|\s+$'))">
                              ERROR: <sch:name/> should not begin or end with spaces.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               <constraintSpec scheme="schematron" ident="noTrailingPeriod.warning">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:name">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'\.$'))" role="warning">
                              WARNING: <sch:name/> usually shouldn't end with periods.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               <constraintSpec scheme="schematron" ident="noTrailingPunct">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:q">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'[\.,]$'))">
                              ERROR: Trailing punctuaton should go outside the <sch:name/> element.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               
               
               <!--CONSTRAINTS WITH QUICK FIXES-->
               
               <constraintSpec scheme="schematron" ident="noStraightQuote">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:body | tei:*[text()][normalize-space(string-join(text(),'')) ne '']">
                           <sch:let name="thisText"
                                    value="if (self::tei:body) then string-join(descendant::text(),'') else string-join(text(),'')"/>
                           <sch:let name="cp" value="string-to-codepoints($thisText)"/>
                           <sch:let name="distinctCp" value="distinct-values($cp)"/>
                           <sch:assert test="empty($distinctCp[.=34])"
                                       sqf:fix="replaceStraightQuotesHere replaceStraightQuotesEverywhere">
                              ERROR: QUICKFIX: Do not use straight quotation marks.
                           </sch:assert>
                           <sqf:fix id="replaceStraightQuotesHere" use-when="self::tei:body">
                              <sqf:description>
                                 <sqf:title>GLOBAL: Replace straight quotation mark with curly question marks everywhere.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="//text()">
                                 <xsl:call-template name="replaceApos">
                                    <xsl:with-param name="useDq" select="true()"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                           <sqf:fix id="replaceStraightQuotesEverywhere" use-when="not(self::tei:body)">
                              <sqf:description>
                                 <sqf:title>LOCAL: Replace straight quotation marks with curly quotation marks in this <sch:name/> element.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="text()">
                                 <xsl:call-template name="replaceApos">
                                    <xsl:with-param name="useDq" select="true()"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               <constraintSpec scheme="schematron" ident="noStraightApos">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:body | tei:*[text()][normalize-space(string-join(text(),'')) ne '']">
                           <sch:let name="thisText"
                                    value="if (self::tei:body) then string-join(descendant::text(),'') else string-join(text(),'')"/>
                           <sch:let name="cp" value="string-to-codepoints($thisText)"/>
                           <sch:let name="distinctCp" value="distinct-values($cp)"/>
                           <sch:assert test="empty($distinctCp[.=39])"
                                       sqf:fix="replaceAposHere replaceAposEverywhere">
                              ERROR: QUICKFIX: Do not use straight apostrophes. 
                           </sch:assert>
                           <sqf:fix id="replaceAposHere" use-when="self::tei:body">
                              <sqf:description>
                                 <sqf:title>GLOBAL: Replace straight apostrophe with curly apostrophe everywhere.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="//text()">
                                 <xsl:call-template name="replaceApos"/>
                              </sqf:replace>
                           </sqf:fix>
                           <sqf:fix id="replaceAposEverywhere" use-when="not(self::tei:body)">
                              <sqf:description>
                                 <sqf:title>LOCAL: Replace straight apostrophe with curly apostrophe in this <sch:name/> element.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="text()">
                                 <xsl:call-template name="replaceApos"/>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               <constraintSpec scheme="schematron" ident="bodyDivsNeedParas">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:body | tei:div | tei:lg">
                           <sch:let name="divs"
                                    value="if (self::tei:body) then (descendant::tei:div) else ."/>
                           <sch:let name="noElContentDivs" value="$divs[not(descendant::*)]"/>
                           <sch:let name="contentDivs"
                                    value="$noElContentDivs[not(normalize-space(string-join(text(),''))='')]"/>
                           <sch:assert test="empty($contentDivs)" sqf:fix="fixDivsHere fixDivsEverywhere">
                              ERROR: QUICKFIX: Untagged text should likely be tagged. Use the Quickfix to do so.
                           </sch:assert>
                           <sqf:fixes>
                              
                              <sqf:fix id="fixDivsHere" use-when="not(self::tei:body)">
                                 <sqf:description>
                                    <sqf:title>LOCAL: Fix this <sch:name/>
                                    </sqf:title>
                                 </sqf:description>
                                 <sqf:replace match="node()">
                                    <xsl:call-template name="tagBlocks">
                                       <xsl:with-param name="verse"
                                                       select="if (parent::*/self::tei:lg) then true() else false()"/>
                                    </xsl:call-template>
                                 </sqf:replace>
                              </sqf:fix>
                              
                              <sqf:fix id="fixDivsEverywhere" use-when="self::tei:body">
                                 <sqf:description>
                                    <sqf:title>GLOBAL: Tag all paragraphs within divs and lines within linegroups.</sqf:title>
                                 </sqf:description>
                                 <sqf:replace match="//tei:div[not(descendant::*)][not(normalize-space(string-join(text(),''))='')]/node() | //tei:lg[not(descendant::*)][not(normalize-space(string-join(text(),''))='')]/node()">
                                    <xsl:call-template name="tagBlocks">
                                       <xsl:with-param name="verse"
                                                       select="if (parent::*/self::tei:lg) then true() else false()"/>
                                    </xsl:call-template>
                                 </sqf:replace>
                              </sqf:fix>
                              
                              
                           </sqf:fixes>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               
               
               <constraintSpec scheme="schematron" ident="bodyQuotesShouldBeTagged">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:body | tei:*[text()][not(normalize-space(string-join(text(),''))='')]">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:let name="containsCurlyQuotes"
                                    value="matches($text,'“') and matches($text,'”')"/>
                           <sch:assert test="not($containsCurlyQuotes)"
                                       sqf:fix="fixQuotesHere fixQuotesEverywhere">
                              ERROR: QUICKFIX: Do not use curly quotes; use the q element instead.
                           </sch:assert>
                           <sqf:fix id="fixQuotesHere">
                              <sqf:description>
                                 <sqf:title>
                                    LOCAL: Replace curly quotes with q elements in this <sch:name/> element.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="text()[contains(.,'“') and contains(.,'”')]">
                                 <xsl:call-template name="tagQuote">
                                    <xsl:with-param name="left" select="'“'"/>
                                    <xsl:with-param name="right" select="'”'"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>         
                           <sqf:fix id="fixQuotesEverywhere" use-when="self::tei:body">
                              <sqf:description>
                                 <sqf:title>GLOBAL: Replace curly quotes with q elements.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="//text()[contains(.,'“') and contains(.,'”')]">
                                 <xsl:call-template name="tagQuote">
                                    <xsl:with-param name="left" select="'“'"/>
                                    <xsl:with-param name="right" select="'”'"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
              
               
            </schemaSpec>
         </div>
         
        
     
      </back>
  </text>
</TEI>
